#pragma once
#include <memory>
#include <functional>
#include <unordered_map>
#include <spdlog/spdlog.h>
#include <AquaEngine/World.hpp>
#include <mono/metadata/assembly.h>
#include <AquaEngine/Scripting/Class.hpp>

namespace AquaEngine
{
	namespace Components { struct Component; }
}

namespace AquaEngine::Scripting
{
	// Forward declaration for 'friend' below
	class ScriptEngine;

	struct Assembly
	{
		AquaAPI struct ManagedComponentData
		{
			size_t Type;

			/// <summary>
			/// Component* (World* world, unsigned int entityID).
			/// Returns created instance of component matching type has <see cref="Type" />
			/// </summary>
			std::function<Components::Component* (World*, unsigned int)> AddFn;
		};

	private:
		/// <summary>
		/// Key:	Managed type index,					generated by Mono
		/// Value:  Struct containing hash of
		///				unmanaged (C++) component (hash code of type_info),
		///				and function for when component is added to an entity
		/// </summary>
		static std::unordered_map<size_t, ManagedComponentData> s_InternalManagedComponentTypes;

		std::vector<MonoClass*> m_ManagedSystemTypes = {};
		std::vector<MonoClass*> m_ManagedComponentTypes = {};

		/// Maps AquaScriptCore managed to unmanaged components (e.g. Transform)
		void LoadScriptCoreTypes();
		
		Assembly(MonoAssembly* handle, bool isCoreAssembly);
		
		friend class AquaEngine::Scripting::ScriptEngine;

	public:
		MonoImage* Image;
		MonoAssembly* Handle;

		AquaAPI MonoClass* GetClassFromName(const char* namespaceName, const char* className);
		AquaAPI MonoType* GetTypeFromClassName(const char* namespaceName, const char* className);

		AquaAPI std::unique_ptr<Class> InstantiateClass(const char* namespaceName, const char* className);

		AquaAPI static size_t GetTypeHash(MonoType* type);
		AquaAPI static size_t GetTypeHash(MonoClass* monoClass);
		AquaAPI static MonoType* GetTypeFromHash(size_t hash);
		AquaAPI static ManagedComponentData GetManagedComponentData(size_t unmanagedType);

		template<typename T>
		static ManagedComponentData GetManagedComponentData()
		{ return GetManagedComponentData(typeid(T).hash_code()); }
	
	private:
		static std::unordered_map<MonoType*, size_t> s_TypeHashes;
		static std::unordered_map<size_t, MonoType*> s_ReverseTypeHashes;
		
		/// <summary>
		/// Hashes all types.
		/// Stores classes deriving AquaEngine.System in <see cref="m_ManagedSystemTypes" />.
		/// Stores classes deriving AquaEngine.Component in <see cref="m_ManagedComponentTypes" />
		/// </summary>
		void CacheTypes(bool isCore);
		void AddInternalCalls();

		// Clears s_TypeHashes & s_ReverseTypeHashes.
		// Intended to be used when reloading assemblies
		static void ClearCachedTypes();

#pragma region Internal Calls
		void AddLogInternalCalls();
		void AddTimeInternalCalls();
		void AddInputInternalCalls();
		void AddCameraInternalCalls();
		void AddWorldInternalCalls();
		void AddVectorInternalCalls();
		void AddTransformInternalCalls();
#pragma endregion

		template<typename T>
		void AddInternalManagedComponent(char* managedNamespace, char* managedName)
		{
			MonoClass* klass = mono_class_from_name(Image, managedNamespace, managedName);
			if (!klass)
			{
				spdlog::warn("Failed to add internal managed component definition for '{}' - not found in assembly '{}'", managedName, mono_image_get_name(Image));
				return;
			}

			MonoType* managedType = mono_class_get_type(klass);
			size_t managedHash = GetTypeHash(managedType);
			size_t hash = typeid(T).hash_code();

			s_InternalManagedComponentTypes.emplace(
				managedHash,
				ManagedComponentData
				{
					hash,
					[](World* world, EntityID entityID) -> Components::Component* { return world->AddComponent<T>(entityID); }
				}
			);

			// Store both native and non-native hashes of this type to the managed (C#) MonoType*
			s_TypeHashes.emplace(managedType, managedHash);
			s_ReverseTypeHashes.emplace(hash, managedType);
			s_ReverseTypeHashes.emplace(managedHash, managedType);
		}
	};
}