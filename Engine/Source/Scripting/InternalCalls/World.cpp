#include <memory>
#include <unordered_map>
#include <mono/jit/jit.h>
#include <spdlog/spdlog.h>
#include <AquaEngine/World.hpp>
#include <AquaEngine/Scripting/Assembly.hpp>
#include <AquaEngine/Components/ScriptComponent.hpp>

// Components to load in to s_InternalManagedComponentTypes
#include <AquaEngine/Components/Camera.hpp>
#include <AquaEngine/Components/Transform.hpp>

using namespace std;
using namespace AquaEngine;

namespace InternalCalls
{
	/// <summary>
	/// Key:	Managed type index,					generated by Mono
	/// Value:  Hash of unmanaged (C++) component,	hash code of type_info
	/// </summary>
	static unordered_map<int, size_t> s_InternalManagedComponentTypes;

	static void (*ComponentInitialiseMethod)(MonoObject*, unsigned int, unsigned int, MonoException**) = nullptr;

#pragma region World
	bool WorldGet(unsigned int worldID, MonoString** outName)
	{
		World* world = World::GetWorld(worldID);
		if (!world)
		{
			*outName = mono_string_new(mono_domain_get(), "");
			return false;
		}

		*outName = mono_string_new(mono_domain_get(), world->Name().c_str());
		return true;
	}

	bool WorldExists(unsigned int worldID)
	{
		return World::GetWorld(worldID) != nullptr;
	}

	bool WorldDestroy(unsigned int worldID)
	{
		World* world = World::GetWorld(worldID);
		if (!world)
			return false;
		world->Destroy();
		delete world;
		return true;
	}

	unsigned int WorldCreate(MonoString* name)
	{
		World* world = new World(mono_string_to_utf8(name));
		return world->ID();
	}

	unsigned int WorldCreateEntity(unsigned int worldID)
	{
		World* world = World::GetWorld(worldID);
		return world ? world->CreateEntity().ID() : InvalidEntityID;
	}
	
	void WorldDestroyEntity(unsigned int worldID, unsigned int entityID)
	{
		World* world = World::GetWorld(worldID);
		if (world)
			world->DestroyEntity(entityID);
	}

	bool WorldHasEntity(unsigned int worldID, unsigned int entityID)
	{
		World* world = World::GetWorld(worldID);
		return world ? world->HasEntity(entityID) : false;
	}
#pragma endregion

#pragma region Entity
	size_t GetComponentType(MonoReflectionType* componentType)
	{
		MonoType* managedTypePtr = mono_reflection_type_get_type(componentType);
		int managedType = mono_type_get_type(managedTypePtr);
		auto it = s_InternalManagedComponentTypes.find(managedType);
		return it != s_InternalManagedComponentTypes.end() ? it->second : managedType;
	}

	bool EntityHasComponent(unsigned int worldID, unsigned int entityID, MonoReflectionType* componentType)
	{
		World* world = World::GetWorld(worldID);
		if (!world || !world->HasEntity(entityID))
			return false;

		return world->GetComponentManager()->Has(entityID, GetComponentType(componentType));
	}

	MonoObject* EntityAddComponent(unsigned int worldID, unsigned int entityID, MonoReflectionType* componentType)
	{
		World* world = World::GetWorld(worldID);
		if (!world)
			return nullptr;
		size_t type = GetComponentType(componentType);

		return nullptr;
	}

	MonoObject* EntityGetComponent(unsigned int worldID, unsigned int entityID, MonoReflectionType* componentType)
	{
		World* world = World::GetWorld(worldID);
		if (!world)
			return nullptr;
		MonoType* managedTypePtr = mono_reflection_type_get_type(componentType);
		int managedType = mono_type_get_type(managedTypePtr);
		auto it = s_InternalManagedComponentTypes.find(managedType);
		void* instance = world->GetComponent(entityID, it == s_InternalManagedComponentTypes.end() ? it->second : managedType);

		if (it != s_InternalManagedComponentTypes.end())
		{
			// Unmanaged (C++) type
			MonoClass* klass = mono_class_from_mono_type(managedTypePtr);
			MonoObject* managed = mono_object_new(mono_domain_get(), klass);
			unsigned int params[2] = { worldID, entityID };

			// Call initialise method
			MonoException* exception = nullptr;
			ComponentInitialiseMethod(managed, worldID, entityID, &exception);

			return managed;
		}
		else // Managed (C#) type
			return ((Components::ScriptComponent*)instance)->Instance;
	}
#pragma endregion
	/// <summary>
	/// Maps an unmanaged (C++) component type to a managed (C#) component
	/// </summary>
	template<typename T>
	void AddInternalManagedComponent(const char* managedName, MonoImage* image)
	{
		MonoType* reflectionType = mono_reflection_type_from_name((char*)managedName, image);
		if (!reflectionType)
		{
			spdlog::warn("Failed to add internal managed component definition for '{}' - not found in assembly '{}'", managedName, mono_image_get_name(image));
			return;
		}

		s_InternalManagedComponentTypes.emplace(
			mono_type_get_type(reflectionType),
			typeid(T).hash_code()
		);
	}

	void AddWorldInternalCalls()
	{
		mono_add_internal_call("AquaEngine.World::_aqua_internal_World_Get", (const void*)WorldGet);
		mono_add_internal_call("AquaEngine.World::_aqua_internal_World_Exists", (const void*)WorldExists);
		mono_add_internal_call("AquaEngine.World::_aqua_internal_World_Create", (const void*)WorldCreate);
		mono_add_internal_call("AquaEngine.World::_aqua_internal_World_Destroy", (const void*)WorldDestroy);
		mono_add_internal_call("AquaEngine.World::_aqua_internal_World_HasEntity", (const void*)WorldHasEntity);
		mono_add_internal_call("AquaEngine.World::_aqua_internal_World_CreateEntity", (const void*)WorldCreateEntity);
		mono_add_internal_call("AquaEngine.World::_aqua_internal_World_DestroyEntity", (const void*)WorldCreateEntity);

		mono_add_internal_call("AquaEngine.Entity::_aqua_internal_Entity_HasComponent", (const void*)EntityHasComponent);
		mono_add_internal_call("AquaEngine.Entity::_aqua_internal_Entity_GetComponent", (const void*)EntityGetComponent);
	}

	AquaAPI void PostCoreAssemblyLoaded(unique_ptr<Scripting::Assembly>& assembly)
	{
		AddInternalManagedComponent<Components::Camera>("AquaEngine.Camera", assembly->Image);
		AddInternalManagedComponent<Components::Transform>("AquaEngine.Transform", assembly->Image);

		MonoMethod* componentInitialiseMethod = mono_class_get_method_from_name(mono_class_from_name(assembly->Image, "AquaEngine", "Component"), "Initialise", 2);
		if (ComponentInitialiseMethod == nullptr && componentInitialiseMethod)
			ComponentInitialiseMethod = (void(*)(MonoObject*, unsigned int, unsigned int, MonoException**))mono_method_get_unmanaged_thunk(componentInitialiseMethod);
	}
}